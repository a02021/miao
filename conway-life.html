<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      background-color:antiquewhite;
      width: max-content;
      height: max-content;
    }
    p {
      color: red;
    }
    #grid {
      /* 检测换行符 */
      white-space:pre-line;
      color:darkred;
      background-color:gold;
      width: max-content;
      height: max-content;
    }
    .opt {
      display:inline-block;
    }

  </style>
</head>
<body>
  <p>class版本</p>
  <div id="grid"></div>
  <div id="hint"></div>
  <br>
  <div>尺寸<input type="range" id="range" min='5' max='25' value='10' onclick="startNew()"></div>
  <button onclick="next()">Next generation</button>
  <div class="opt"><input type="checkbox" id="ifAuto" onclick="autoNext()">自动进化!</div>
  <div class="opt"><input type="checkbox" id="cancelB" onclick="cancelB()">取消边境!</div>
  <button onclick="clearAll()">清空</button>
  <button onclick="randomNew()">重新随机</button>
  <script>
    class Conway {
      constructor(width, height, boundary) {
        this.width = width
        this.height = height
        this.boundary = boundary
        this.world = new Array(width).fill([]).map(i => i = new Array(height).fill(0))
      }
      get(row, col) {
        if (row < 0) row = this.width -1
        if (row > this.width) row = 0
        if (col < 0) col = this.height -1
        if (col > this.col) row = 0
        return this.world[row][col]
      }
      set(row, col, val) {
        this.world[row][col] = val
      }
      printWorld(callback) {
        return callback(this.world)
      }
      randomFill(ratio = 0.5) {
        this.world = this.world.map(it => it = it.map(n => 
          n = Math.random() > ratio ? 0 : 1))
      }
      setBoundary(b) {
        this.boundary = b
      }
      neighborsCount(row, col) {
        let count = 0
        if (this.boundary) {
          let iLength = row + 1 > this.width - 1 ? this.width - 1 : row + 1
          let jLength = col + 1 > this.height - 1 ? this.height - 1: col + 1        
          for (let i = row - 1 < 0 ? 0 : row - 1; i <= iLength; i++) {
             for (let j = col - 1 < 0 ? 0 : col - 1; j <= jLength; j++) {
              // console.log(i,j,this.world[i][j])
             if (this.world[i][j] === 1) count++
            }
          }
        }
        if (!this.boundary) {
          console.log(this.boundary)
          let iLength = row + 1 
          let jLength = col + 1 
          for (let i = row - 1 ; i <= iLength; i++) {
             for (let j = col - 1 ; j <= jLength; j++) {
              let r = i 
              let c = j
              if (i == -1) r = this.width - 1
              if (i == this.width ) r = 0
              if (j == -1) c =  this.height - 1
              if (j == this.height ) c = 0
              if (this.world[r][c] === 1) count++
            }
          }
        }
        //少于两个或多于三个的活着的邻居，都会死亡
        // console.log('co',row,col,count)
        if (this.world[row][col] === 1) {
          count--
          if (count < 2 || count > 3) {
            return false
          } else {
            return true
          }
        } else {//死去的细胞，周围有三个活着的邻居，可以再次复活。
          if (count === 3) {
            return true
          }
        }
        return false
      }
      next() {
        let newWorld = []
        for (let row = 0; row < this.width; row++) {
          newWorld[row] = []
          for (let col =0; col < this.height; col++) {
            if(this.neighborsCount(row, col)) {
              newWorld[row][col] = 1
            } else {
              newWorld[row][col] = 0
            }
          }
        }
        this.world = newWorld
      }
    }

    let newGame, nGen, long, autoPlay
    let range = document.querySelector('#range')
    let grid = document.querySelector('#grid')
    startNew()
    function startWorld(width, height, ratio = 0.5) {
      nGen = 0
      newGame = new Conway(width, height, true)
      newGame.randomFill(ratio)
      newGame.printWorld(printHTML)
    }
    grid.addEventListener('click', e => {
      let row = e.target.dataset.row
      let col = e.target.dataset.col
      //防止点到空白处 无法获取值
      if (row && col){
        newGame.set(row, col, newGame.world[row][col] == 1 ? 0 : 1)
      }
    })
    function startNew() {
      long = Number(range.value)
      startWorld(long, long, 0.5)
      autoNext()
      cancelB()
    }
    function printHTML(m) {
      grid.innerHTML = ''
      for (let row = 0; row < m.length; row++) {
        for (let col = 0; col < m[row].length; col++) {
          if (m[row][col] === 0) grid.innerHTML += `<input type="checkbox" data-row="${row}" data-col="${col}">`
          if (m[row][col] === 1) grid.innerHTML += `<input type="checkbox" checked data-row="${row}" data-col="${col}">`
        }
        grid.innerHTML += '\n'
      }
      document.querySelector('#hint').innerHTML = '第' + nGen++ + '代'
    }
    function next() {
      newGame.next()
      newGame.printWorld(printHTML)
    }
    function clearAll() {
      startWorld(long, long, 0)
    }
    function randomNew() {
      startWorld(long, long, 0.5)
    }
    function autoNext() {
      let ifAuto = document.querySelector('#ifAuto')
      if (ifAuto.checked) {
        autoPlay = setInterval(next, 500)
      } else {
        clearInterval(autoPlay)
      }
    }
    function cancelB() {
      let ifBoundary = document.querySelector('#cancelB')
      if (ifBoundary.checked) {
        newGame.setBoundary(false)
        grid.style.border = ''
      } else {
        newGame.setBoundary(true)
        grid.style.border = '2px solid red'
      }

    }

  </script>
</body>
</html>